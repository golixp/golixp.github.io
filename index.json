[{"content":"","date":"2024-04-16","externalUrl":null,"permalink":"/","section":"Lixp的Blog","summary":"","title":"Lixp的Blog","type":"page"},{"content":"","date":"2024-04-16","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"默认配置下的git在修改包含中文内容的时候, 会出现如下情况:\n位于分支 writer 您的分支与上游分支 \u0026#39;origin/writer\u0026#39; 一致。 尚未暂存以备提交的变更： （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 更新要提交的内容） （使用 \u0026#34;git restore \u0026lt;文件\u0026gt;...\u0026#34; 丢弃工作区的改动） 修改： .gitignore 修改： \u0026#34;content/posts/\\346\\265\\213\\350\\257\\225\\346\\226\\207\\347\\253\\240.md\u0026#34; 修改尚未加入提交（使用 \u0026#34;git add\u0026#34; 和/或 \u0026#34;git commit -a\u0026#34;） 可以看到中文显示为ASCII编码, 这是由于Git的core.quotepath配置默认是true, 它会将所有非ASCII字符转换为ASCII编码，因此中文路径和文件名会显示为不可读的字符。\n使用命令git config --global core.quotepath false可以不将非ASCII字符的文件名进行编码转换, 更改后显示如下:\n位于分支 writer 您的分支与上游分支 \u0026#39;origin/writer\u0026#39; 一致。 尚未暂存以备提交的变更： （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 更新要提交的内容） （使用 \u0026#34;git restore \u0026lt;文件\u0026gt;...\u0026#34; 丢弃工作区的改动） 修改： .gitignore 修改： content/posts/测试文章.md 修改尚未加入提交（使用 \u0026#34;git add\u0026#34; 和/或 \u0026#34;git commit -a\u0026#34;） ","date":"2024-04-16","externalUrl":null,"permalink":"/posts/%E7%BB%88%E7%AB%AF%E4%B8%ADgit%E4%BF%A1%E6%81%AF%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B8%BAascii%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/","section":"Posts","summary":"默认配置下的git在修改包含中文内容的时候, 会出现如下情况:","title":"终端中git信息中文显示为ASCII编码问题","type":"posts"},{"content":"编辑文件~/.config/kwalletrc:\n[Auto Deny] kdewallet=codium 在其中加入你需要启动的应用名称\n","date":"2024-04-16","externalUrl":null,"permalink":"/posts/kde%E4%B8%AD%E6%AF%8F%E6%AC%A1%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E9%83%BD%E7%94%B3%E8%AF%B7%E5%BC%80%E5%90%AFkdewallet%E7%9A%84%E9%97%AE%E9%A2%98/","section":"Posts","summary":"编辑文件~/.config/kwalletrc:","title":"KDE中每次启动应用都申请开启kdewallet的问题","type":"posts"},{"content":"今天push的时候看到仓库有些commit是使用公司的邮箱提交的, 需要修改所有历史commit中的提交作者信息\nfilter-branch # 查询网上信息发现了filter-branch脚本, 如下:\n#!/bin/sh git filter-branch --env-filter \u0026#39; OLD_EMAIL=\u0026#34;旧邮箱\u0026#34; CORRECT_NAME=\u0026#34;新名字\u0026#34; CORRECT_EMAIL=\u0026#34;新邮箱\u0026#34; if [ \u0026#34;$GIT_COMMITTER_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_COMMITTER_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_COMMITTER_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi if [ \u0026#34;$GIT_AUTHOR_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_AUTHOR_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_AUTHOR_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi \u0026#39; --tag-name-filter cat -- --branches --tags 修改信息运行后报警告:\nWARNING: git-filter-branch has a glut of gotchas generating mangled history rewrites. Hit Ctrl-C before proceeding to abort, then use an alternative filtering tool such as \u0026#39;git filter-repo\u0026#39; (https://github.com/newren/git-filter-repo/) instead. See the filter-branch manual page for more details; to squelch this warning, set FILTER_BRANCH_SQUELCH_WARNING=1. Proceeding with filter-branch... Rewrite 256e869ada89ce0adae33aa01a732c9a71b00992 (1/1) (0 seconds passed, remaining 0 predicted) Ref \u0026#39;refs/heads/master\u0026#39; was rewritten 查询后发现git-filter-branch已被官方弃用, 改用新的基于Python3编写的工具 git-filter-repo.\ngit-filter-repo # 需要通过pip install git-filter-repo安装\n之后运行命令:\ngit filter-repo \\ --email-callback \u0026#39; return email if email != b\u0026#34;OLD_EMAIL\u0026#34; else b\u0026#34;NEW_EMAIL\u0026#34; \u0026#39; \\ --name-callback \u0026#39;return name.replace(b\u0026#34;OLD_AUTHOR\u0026#34;, b\u0026#34;NEW_AUTHOR\u0026#34;)\u0026#39; \\ --force 总结 # 经过尝试之后, 发现不论是filter-branch还是git-filter-repo都无法去除远程仓库中的所有提交信息, 在.git中还是会保留, 然而直接删除.git的相关内容会导致某些历史的文件损坏, 所以放弃修改, 除了看commit历史的时候有些不顺眼之外也没什么影响.\n","date":"2024-04-16","externalUrl":null,"permalink":"/posts/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9git%E4%BB%93%E5%BA%93%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4%E4%BD%9C%E8%80%85%E4%BF%A1%E6%81%AF/","section":"Posts","summary":"今天push的时候看到仓库有些commit是使用公司的邮箱提交的, 需要修改所有历史commit中的提交作者信息","title":"批量修改git仓库历史提交作者信息","type":"posts"},{"content":" 需求 # 现有两个目录, 其中图片image/source/目录部分内容:\n-rw-r--r-- 1 root root 632719 May 16 2023 20230516091500_8ea8f4755ab211ed864a0050569539e0.jpg -rw-r--r-- 1 root root 165811 May 16 2023 20230516091500_9535f376ca0611ed9d690050569539e0.jpg -rw-r--r-- 1 root root 282415 May 16 2023 20230516091500_a08f20f9cdf111ed9d690050569539e0.jpg ... 音频目录audio部分内容:\ndrwxr-xr-x 2 root root 4096 Apr 1 15:33 ffe4db567548a8852daa715ef23336b8 drwxr-xr-x 2 root root 12288 Mar 12 18:18 fff75084e08309e56bbb6034f00ca75d drwxr-xr-x 2 root root 4096 Oct 31 15:33 fffd822ac90a7546cf5ab457c8a1ca64 ... 音频目录下一个子目录audio/fffd822ac90a7546cf5ab457c8a1ca64下内容:\n-rw-r--r-- 1 root root 176090 Oct 31 15:30 20231031152954_e25e2be5ba9011ed9d690050569539e0.wav -rw-r--r-- 1 root root 176090 Oct 31 15:32 20231031153154_e25e2be5ba9011ed9d690050569539e0.wav -rw-r--r-- 1 root root 176090 Oct 31 15:34 20231031153354_e25e2be5ba9011ed9d690050569539e0.wav ... 其中image/source/目录下文件名中的uuid代表摄像头id, 与audio子目录下wav文件的文件名中的uuid含义一致, 但是与audio目录下的子目录名称无关.\n现要求将两个目录下相近时间记录的音频和图片一一对应.\n例如: 20231031091500_a08f20f9cdf111ed9d690050569539e0.jpg 与 20231031091454_a08f20f9cdf111ed9d690050569539e0.wav 对应.\n提取文件列表 # 首先用find命令提取完整的audio所有子目录文件列表\nfind audio/ -type f \u0026gt; audio.txt 文件内容:\naudio/140cb49659d4105009c8c8ca4d539cd9/20231020195154_547a1f69ca0611ed9d690050569539e0.wav audio/140cb49659d4105009c8c8ca4d539cd9/20231020193554_547a1f69ca0611ed9d690050569539e0.wav audio/140cb49659d4105009c8c8ca4d539cd9/20231020202754_547a1f69ca0611ed9d690050569539e0.wav image/source/目录下是完整的文件列表, 没有子目录层级, 所以使用ls命令提取:\nls -1 image/source/ \u0026gt; img.txt 文件内容:\n20230303153200_b999967758c411ed864a0050569539e0.jpg 20230305084000_3103656d5ab511ed864a0050569539e0.jpg 20230305084000_3a4bb49e5ab511ed864a0050569539e0.jpg 解析文件名 # 由观察可以得知文件名称格式固定, 由14位日期+32位uuid+后缀构成. 编写解析函数:\n直接切割:\ndef split(s): return (s[0:14], s[15:48], s[-3:]) 根据符号切割:\ndef split(s): return ( s[0 : s.find(\u0026#34;_\u0026#34;)], s[s.find(\u0026#34;_\u0026#34;) + 1 : s.find(\u0026#34;.\u0026#34;)], s[s.find(\u0026#34;.\u0026#34;) + 1 :] ) 运行:\nprint(split(\u0026#34;20230303153200_b999967758c411ed864a0050569539e0.jpg\u0026#34;)) 输出:\n(\u0026#39;20230303153200\u0026#39;, \u0026#39;b999967758c411ed864a0050569539e0\u0026#39;, \u0026#39;jpg\u0026#39;) 提取特征 # 由于要对比20231031091500_a08f20f9cdf111ed9d690050569539e0.jpg 与 20231031091454_a08f20f9cdf111ed9d690050569539e0.wav 这种对应关系, 只需要让音频文件精确到分钟的时间+1分钟等于图片的时间即为同时的图片, 将精确到分钟的时间和后面的uuid拼接为字符串, 字符串相等, 图片和音频就对应上了.\n处理images目录文件列表 # 文件较小, 不到60MB, 不需要优化内存占用, 所以直接加载到内存在内存处理\ndef img(): with open(\u0026#34;匹配图片/img.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: # 读取并去除换行符 data = f.read().splitlines() res = dict() for i in data: timestamp, uuid, _ = split(i) trait = timestamp[:-2] + uuid res[trait] = i return res 解析audio目录文件列表 # 和images目录类似, 需要注意处理文件路径, 还有时间+1分钟需要转换为时间对象, 这样可以比较方便地进行60进制运算.\ndef audio(): with open(\u0026#34;匹配图片/audio.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: # 读取并去除换行符 data = f.read().splitlines() res = dict() for i in data: timestamp, uuid, _ = split(i[i.rfind(\u0026#34;/\u0026#34;) + 1 :]) # 将时间+1分钟 date_time = datetime.strptime(timestamp, r\u0026#34;%Y%m%d%H%M%S\u0026#34;) + timedelta(minutes=1) timestamp = date_time.strftime(r\u0026#34;%Y%m%d%H%M%S\u0026#34;) trait = timestamp[:-2] + uuid res[trait] = i return res 比较两个目录文件列表 # imgd = img() audiod = audio() res = list() for key, value in audiod.items(): if key in imgd: res.append((\u0026#34;image/source/\u0026#34; + imgd[key], value)) print(res) 复制文件 # for i in res: _, uuid, _ = split(i[0][i[0].rfind(\u0026#34;/\u0026#34;) + 1 :]) target = Path(f\u0026#34;data/{uuid}\u0026#34;) target.mkdir(parents=True, exist_ok=True) shutil.copy(i[0], target) shutil.copy(i[1], target) 最终代码 # import shutil from datetime import datetime, timedelta from pathlib import Path def split(s): return (s[0 : s.find(\u0026#34;_\u0026#34;)], s[s.find(\u0026#34;_\u0026#34;) + 1 : s.find(\u0026#34;.\u0026#34;)], s[s.find(\u0026#34;.\u0026#34;) + 1 :]) def img(): with open(\u0026#34;img.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: # 读取并去除换行符 data = f.read().splitlines() res = dict() for i in data: timestamp, uuid, _ = split(i) trait = timestamp[:-2] + uuid res[trait] = i return res def audio(): with open(\u0026#34;audio.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: # 读取并去除换行符 data = f.read().splitlines() res = dict() for i in data: timestamp, uuid, _ = split(i[i.rfind(\u0026#34;/\u0026#34;) + 1 :]) # 将时间+1分钟 date_time = datetime.strptime(timestamp, r\u0026#34;%Y%m%d%H%M%S\u0026#34;) + timedelta(minutes=1) timestamp = date_time.strftime(r\u0026#34;%Y%m%d%H%M%S\u0026#34;) trait = timestamp[:-2] + uuid res[trait] = i return res if __name__ == \u0026#34;__main__\u0026#34;: imgd = img() audiod = audio() res = list() for key, value in audiod.items(): if key in imgd: res.append((\u0026#34;image/source/\u0026#34; + imgd[key], value)) print(res) ... # 复制文件 for i in res: _, uuid, _ = split(i[0][i[0].rfind(\u0026#34;/\u0026#34;) + 1 :]) target = Path(f\u0026#34;data/{uuid}\u0026#34;) target.mkdir(parents=True, exist_ok=True) shutil.copy(i[0], target) shutil.copy(i[1], target) ","date":"2024-04-16","externalUrl":null,"permalink":"/posts/python%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99-%E5%8C%B9%E9%85%8D%E5%90%8C%E6%97%B6%E9%97%B4%E6%AE%B5%E7%9A%84%E9%9F%B3%E9%A2%91%E5%92%8C%E5%9B%BE%E7%89%87/","section":"Posts","summary":"需求 # 现有两个目录, 其中图片image/source/目录部分内容:","title":"Python脚本编写-匹配同时间段的音频和图片","type":"posts"},{"content":" 创建conda环境 # conda create -n moused python=3.10 进入conda环境 # conda activate moused 配置环境 # mkdir moused cd moused pip install ultralytics 预测 # yolo detect predict model=yolov8x.pt source=mouse.mp4 效果并不好, 需要使用自定义数据集微调.\n使用自定义数据集微调 # 经过挑选, 下载安装X-AnyLabeling作为数据标注工具, 截取一些有老鼠的图像, 并且标注检测框, 标注完成后, 新建一个标签文件classes.txt, 内容如下:\nmouse 选择导出为yolo标签, 会在图片目录同级出现labels目录.\n拆分训练集 # 将image目录和labels目录放到一个data目录下, 然后运行如下代码:\nimport os import random import shutil # 设置随机数种子 random.seed(123) # 定义文件夹路径 root_dir = \u0026#39;data\u0026#39; image_dir = os.path.join(root_dir, \u0026#39;images\u0026#39;) label_dir = os.path.join(root_dir, \u0026#39;labels\u0026#39;) output_dir = \u0026#39;dataset\u0026#39; # 定义训练集、验证集和测试集比例 train_ratio = 0.7 valid_ratio = 0.15 test_ratio = 0.15 # 获取所有图像文件和标签文件的文件名（不包括文件扩展名） image_filenames = [os.path.splitext(f)[0] for f in os.listdir(image_dir)] label_filenames = [os.path.splitext(f)[0] for f in os.listdir(label_dir)] # 随机打乱文件名列表 random.shuffle(image_filenames) # 计算训练集、验证集和测试集的数量 total_count = len(image_filenames) train_count = int(total_count * train_ratio) valid_count = int(total_count * valid_ratio) test_count = total_count - train_count - valid_count # 定义输出文件夹路径 train_image_dir = os.path.join(output_dir, \u0026#39;train\u0026#39;, \u0026#39;images\u0026#39;) train_label_dir = os.path.join(output_dir, \u0026#39;train\u0026#39;, \u0026#39;labels\u0026#39;) valid_image_dir = os.path.join(output_dir, \u0026#39;valid\u0026#39;, \u0026#39;images\u0026#39;) valid_label_dir = os.path.join(output_dir, \u0026#39;valid\u0026#39;, \u0026#39;labels\u0026#39;) test_image_dir = os.path.join(output_dir, \u0026#39;test\u0026#39;, \u0026#39;images\u0026#39;) test_label_dir = os.path.join(output_dir, \u0026#39;test\u0026#39;, \u0026#39;labels\u0026#39;) # 创建输出文件夹 os.makedirs(train_image_dir, exist_ok=True) os.makedirs(train_label_dir, exist_ok=True) os.makedirs(valid_image_dir, exist_ok=True) os.makedirs(valid_label_dir, exist_ok=True) os.makedirs(test_image_dir, exist_ok=True) os.makedirs(test_label_dir, exist_ok=True) # 将图像和标签文件划分到不同的数据集中 for i, filename in enumerate(image_filenames): if i \u0026lt; train_count: output_image_dir = train_image_dir output_label_dir = train_label_dir elif i \u0026lt; train_count + valid_count: output_image_dir = valid_image_dir output_label_dir = valid_label_dir else: output_image_dir = test_image_dir output_label_dir = test_label_dir # 复制图像文件 src_image_path = os.path.join(image_dir, filename + \u0026#39;.png\u0026#39;) dst_image_path = os.path.join(output_image_dir, filename + \u0026#39;.png\u0026#39;) shutil.copy(src_image_path, dst_image_path) # 复制标签文件 src_label_path = os.path.join(label_dir, filename + \u0026#39;.txt\u0026#39;) dst_label_path = os.path.join(output_label_dir, filename + \u0026#39;.txt\u0026#39;) shutil.copy(src_label_path, dst_label_path) 将拆分出训练集/验证集/测试集.\n训练 # 创建data.yml文件, 内容如下:\ntrain: /home/user/moused/dataset/train # train images (relative to \u0026#39;path\u0026#39;) 128 images val: /home/user/moused/dataset/valid # val images (relative to \u0026#39;path\u0026#39;) 128 images test: /home/user/moused/dataset/test # test images (optional) # Classes names: 0: mouse 运行命令yolo detect train data=data.yml model=yolov8x.pt epochs=100 imgsz=640, 将开始训练.\n预测 # yolo detect predict model=runs/detect/train/weights/best.pt source=mouse.mp4 效果还不错\n","date":"2024-04-15","externalUrl":null,"permalink":"/posts/%E4%BD%BF%E7%94%A8yolo-v8%E6%A3%80%E6%B5%8B%E8%A7%86%E9%A2%91%E4%B8%AD%E7%9A%84%E8%80%81%E9%BC%A0/","section":"Posts","summary":"创建conda环境 # conda create -n moused python=3.","title":"使用yolo-v8检测视频中的老鼠","type":"posts"},{"content":" 这是一级标题 # 这是二级标题 # 这是三级标题 # 这是普通文本的段落。你可以通过星号 * 和下划线 _ 来使用 斜体 或 斜体。\n加粗 文本可以使用两个星号 ** 或两个下划线 __ 来实现。\n这是有序列表的第一项 这是有序列表的第二项 这是子列表的第一项 这是子列表的第二项 这是无序列表的第一项 这是无序列表的第二项 这是子列表的第一项 这是子列表的第二项 链接 百度首页\n图片\n图片标题 这是一段引用文本。\n这是一行代码\n这是一个代码块 可以包含多行代码 这是一条水平线\n表头1 表头2 表头3 单元格1 单元格2 单元格3 单元格4 单元格5 单元格6 ","date":"2024-04-07","externalUrl":null,"permalink":"/posts/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","section":"Posts","summary":"这是一级标题 # 这是二级标题 # 这是三级标题 # 这是普通文本的段落。你可以通过星号 * 和下划线 _ 来使用 斜体 或 斜体。","title":"测试文章","type":"posts"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]