[{"content":"","date":"2024-04-16","externalUrl":null,"permalink":"/","section":"Lixp的Blog","summary":"","title":"Lixp的Blog","type":"page"},{"content":"","date":"2024-04-16","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" 需求 # 现有两个目录, 其中图片image/source/目录部分内容:\n-rw-r--r-- 1 root root 632719 May 16 2023 20230516091500_8ea8f4755ab211ed864a0050569539e0.jpg -rw-r--r-- 1 root root 165811 May 16 2023 20230516091500_9535f376ca0611ed9d690050569539e0.jpg -rw-r--r-- 1 root root 282415 May 16 2023 20230516091500_a08f20f9cdf111ed9d690050569539e0.jpg ... 音频目录audio部分内容:\ndrwxr-xr-x 2 root root 4096 Apr 1 15:33 ffe4db567548a8852daa715ef23336b8 drwxr-xr-x 2 root root 12288 Mar 12 18:18 fff75084e08309e56bbb6034f00ca75d drwxr-xr-x 2 root root 4096 Oct 31 15:33 fffd822ac90a7546cf5ab457c8a1ca64 ... 音频目录下一个子目录audio/fffd822ac90a7546cf5ab457c8a1ca64下内容:\n-rw-r--r-- 1 root root 176090 Oct 31 15:30 20231031152954_e25e2be5ba9011ed9d690050569539e0.wav -rw-r--r-- 1 root root 176090 Oct 31 15:32 20231031153154_e25e2be5ba9011ed9d690050569539e0.wav -rw-r--r-- 1 root root 176090 Oct 31 15:34 20231031153354_e25e2be5ba9011ed9d690050569539e0.wav ... 其中image/source/目录下文件名中的uuid代表摄像头id, 与audio子目录下wav文件的文件名中的uuid含义一致, 但是与audio目录下的子目录名称无关.\n现要求将两个目录下相近时间记录的音频和图片一一对应.\n例如: 20231031091500_a08f20f9cdf111ed9d690050569539e0.jpg 与 20231031091454_a08f20f9cdf111ed9d690050569539e0.wav 对应.\n提取文件列表 # 首先用find命令提取完整的audio所有子目录文件列表\nfind audio/ -type f \u0026gt; audio.txt 文件内容:\naudio/140cb49659d4105009c8c8ca4d539cd9/20231020195154_547a1f69ca0611ed9d690050569539e0.wav audio/140cb49659d4105009c8c8ca4d539cd9/20231020193554_547a1f69ca0611ed9d690050569539e0.wav audio/140cb49659d4105009c8c8ca4d539cd9/20231020202754_547a1f69ca0611ed9d690050569539e0.wav image/source/目录下是完整的文件列表, 没有子目录层级, 所以使用ls命令提取:\nls -1 image/source/ \u0026gt; img.txt 文件内容:\n20230303153200_b999967758c411ed864a0050569539e0.jpg 20230305084000_3103656d5ab511ed864a0050569539e0.jpg 20230305084000_3a4bb49e5ab511ed864a0050569539e0.jpg 解析文件名 # 由观察可以得知文件名称格式固定, 由14位日期+32位uuid+后缀构成. 编写解析函数:\n直接切割:\ndef split(s): return (s[0:14], s[15:48], s[-3:]) 根据符号切割:\ndef split(s): return ( s[0 : s.find(\u0026#34;_\u0026#34;)], s[s.find(\u0026#34;_\u0026#34;) + 1 : s.find(\u0026#34;.\u0026#34;)], s[s.find(\u0026#34;.\u0026#34;) + 1 :] ) 运行:\nprint(split(\u0026#34;20230303153200_b999967758c411ed864a0050569539e0.jpg\u0026#34;)) 输出:\n(\u0026#39;20230303153200\u0026#39;, \u0026#39;b999967758c411ed864a0050569539e0\u0026#39;, \u0026#39;jpg\u0026#39;) 提取特征 # 由于要对比20231031091500_a08f20f9cdf111ed9d690050569539e0.jpg 与 20231031091454_a08f20f9cdf111ed9d690050569539e0.wav 这种对应关系, 只需要让音频文件精确到分钟的时间+1分钟等于图片的时间即为同时的图片, 将精确到分钟的时间和后面的uuid拼接为字符串, 字符串相等, 图片和音频就对应上了.\n处理images目录文件列表 # 文件较小, 不到60MB, 不需要优化内存占用, 所以直接加载到内存在内存处理\ndef img(): with open(\u0026#34;匹配图片/img.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: # 读取并去除换行符 data = f.read().splitlines() res = dict() for i in data: timestamp, uuid, _ = split(i) trait = timestamp[:-2] + uuid res[trait] = i return res 解析audio目录文件列表 # 和images目录类似, 需要注意处理文件路径, 还有时间+1分钟需要转换为时间对象, 这样可以比较方便地进行60进制运算.\ndef audio(): with open(\u0026#34;匹配图片/audio.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: # 读取并去除换行符 data = f.read().splitlines() res = dict() for i in data: timestamp, uuid, _ = split(i[i.rfind(\u0026#34;/\u0026#34;) + 1 :]) # 将时间+1分钟 date_time = datetime.strptime(timestamp, r\u0026#34;%Y%m%d%H%M%S\u0026#34;) + timedelta(minutes=1) timestamp = date_time.strftime(r\u0026#34;%Y%m%d%H%M%S\u0026#34;) trait = timestamp[:-2] + uuid res[trait] = i return res 比较两个目录文件列表 # imgd = img() audiod = audio() res = list() for key, value in audiod.items(): if key in imgd: res.append((\u0026#34;image/source/\u0026#34; + imgd[key], value)) print(res) 复制文件 # for i in res: _, uuid, _ = split(i[0][i[0].rfind(\u0026#34;/\u0026#34;) + 1 :]) target = Path(f\u0026#34;data/{uuid}\u0026#34;) target.mkdir(parents=True, exist_ok=True) shutil.copy(i[0], target) shutil.copy(i[1], target) 最终代码 # import shutil from datetime import datetime, timedelta from pathlib import Path def split(s): return (s[0 : s.find(\u0026#34;_\u0026#34;)], s[s.find(\u0026#34;_\u0026#34;) + 1 : s.find(\u0026#34;.\u0026#34;)], s[s.find(\u0026#34;.\u0026#34;) + 1 :]) def img(): with open(\u0026#34;img.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: # 读取并去除换行符 data = f.read().splitlines() res = dict() for i in data: timestamp, uuid, _ = split(i) trait = timestamp[:-2] + uuid res[trait] = i return res def audio(): with open(\u0026#34;audio.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: # 读取并去除换行符 data = f.read().splitlines() res = dict() for i in data: timestamp, uuid, _ = split(i[i.rfind(\u0026#34;/\u0026#34;) + 1 :]) # 将时间+1分钟 date_time = datetime.strptime(timestamp, r\u0026#34;%Y%m%d%H%M%S\u0026#34;) + timedelta(minutes=1) timestamp = date_time.strftime(r\u0026#34;%Y%m%d%H%M%S\u0026#34;) trait = timestamp[:-2] + uuid res[trait] = i return res if __name__ == \u0026#34;__main__\u0026#34;: imgd = img() audiod = audio() res = list() for key, value in audiod.items(): if key in imgd: res.append((\u0026#34;image/source/\u0026#34; + imgd[key], value)) print(res) ... # 复制文件 for i in res: _, uuid, _ = split(i[0][i[0].rfind(\u0026#34;/\u0026#34;) + 1 :]) target = Path(f\u0026#34;data/{uuid}\u0026#34;) target.mkdir(parents=True, exist_ok=True) shutil.copy(i[0], target) shutil.copy(i[1], target) ","date":"2024-04-16","externalUrl":null,"permalink":"/posts/python%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99-%E5%8C%B9%E9%85%8D%E5%90%8C%E6%97%B6%E9%97%B4%E6%AE%B5%E7%9A%84%E9%9F%B3%E9%A2%91%E5%92%8C%E5%9B%BE%E7%89%87/","section":"Posts","summary":"需求 # 现有两个目录, 其中图片image/source/目录部分内容:","title":"Python脚本编写 匹配同时间段的音频和图片","type":"posts"},{"content":" 这是一级标题 # 这是二级标题 # 这是三级标题 # 这是普通文本的段落。你可以通过星号 * 和下划线 _ 来使用 斜体 或 斜体。\n加粗 文本可以使用两个星号 ** 或两个下划线 __ 来实现。\n这是有序列表的第一项 这是有序列表的第二项 这是子列表的第一项 这是子列表的第二项 这是无序列表的第一项 这是无序列表的第二项 这是子列表的第一项 这是子列表的第二项 链接 百度首页\n图片\n图片标题 这是一段引用文本。\n这是一行代码\n这是一个代码块 可以包含多行代码 这是一条水平线\n表头1 表头2 表头3 单元格1 单元格2 单元格3 单元格4 单元格5 单元格6 ","date":"2024-04-07","externalUrl":null,"permalink":"/posts/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","section":"Posts","summary":"这是一级标题 # 这是二级标题 # 这是三级标题 # 这是普通文本的段落。你可以通过星号 * 和下划线 _ 来使用 斜体 或 斜体。","title":"测试文章","type":"posts"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]